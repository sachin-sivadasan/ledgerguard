@startuml SEQUENCE_LedgerGuard_Current
!theme plain

title LedgerGuard - Sequence Diagrams (Current Implementation)

' ==========================================
' 1. Authentication Flow
' ==========================================
newpage Authentication Flow

actor User
participant "Client App" as App
participant "Firebase Auth" as Firebase
participant "API Server" as API
database "PostgreSQL" as DB

User -> App: Login with Google
App -> Firebase: signInWithGoogle()
Firebase --> App: Firebase ID Token

App -> API: Request with\nAuthorization: Bearer <token>
API -> API: AuthMiddleware intercepts

API -> Firebase: verifyIdToken(token)
Firebase --> API: { uid, email }

API -> DB: SELECT * FROM users\nWHERE firebase_uid = ?

alt User exists
    DB --> API: User record
else New user (first login)
    API -> DB: INSERT INTO users\n(firebase_uid, email, role='OWNER')
    DB --> API: New user record
end

API -> API: Set user in request context
API -> API: Continue to handler
API --> App: Response with user context

' ==========================================
' 2. Role-Based Access Control
' ==========================================
newpage Role-Based Access Control

actor User
participant "Client App" as App
participant "API Server" as API

App -> API: Request to protected endpoint\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware\n(verify token, load user)

API -> API: RoleMiddleware\n(check RequireRoles)

alt User has required role
    note right of API: OWNER has access to all routes\nADMIN only to ADMIN routes
    API -> API: Continue to handler
    API --> App: 200 OK + Response
else Insufficient permissions
    API --> App: 403 Forbidden\n{"error": "insufficient permissions"}
end

' ==========================================
' 3. Shopify Partner OAuth Flow
' ==========================================
newpage Shopify Partner OAuth Flow

actor User
participant "Client App" as App
participant "API Server" as API
participant "Shopify Partners" as Shopify
database "PostgreSQL" as DB

User -> App: Click "Connect Shopify"

App -> API: GET /api/v1/integrations/shopify/oauth\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> API: Generate OAuth state token
API -> API: Build Shopify OAuth URL\n(client_id, redirect_uri, scopes, state)

API --> App: 302 Redirect to Shopify

App -> Shopify: GET /oauth/authorize?...
Shopify --> User: "Authorize LedgerGuard?"

User -> Shopify: Click "Approve"

Shopify --> App: 302 Redirect to callback\n?code=xxx&state=yyy

App -> API: GET /api/v1/integrations/shopify/callback\n?code=xxx&state=yyy

API -> API: Validate state token
API -> API: Get user from context

API -> Shopify: POST /oauth/access_token\n{ code, client_id, client_secret }
Shopify --> API: { access_token, organization_id }

API -> API: Encrypt token\n(AES-256-GCM)

API -> DB: INSERT INTO partner_accounts\n(user_id, partner_id, integration_type='OAUTH',\nencrypted_access_token)

DB --> API: Success

API --> App: 200 OK\n{"success": true, "partner_id": "..."}

App --> User: "Connected successfully!"

' ==========================================
' 4. Manual Token Flow (ADMIN only)
' ==========================================
newpage Manual Token Flow (ADMIN only)

actor Admin
participant "Client App" as App
participant "API Server" as API
database "PostgreSQL" as DB

== Add Manual Token ==

Admin -> App: Enter partner token & ID
App -> API: POST /api/v1/integrations/shopify/token\n[Authorization: Bearer <token>]\n{ "token": "shppa_xxx", "partner_id": "12345" }

API -> API: AuthMiddleware (verify user)
API -> API: RoleMiddleware (require ADMIN)

alt User is ADMIN or OWNER
    API -> API: Encrypt token (AES-256-GCM)
    API -> DB: INSERT/UPDATE partner_accounts
    DB --> API: Success
    API --> App: 201 Created\n{ "masked_token": "***...xxxx" }
else Not ADMIN
    API --> App: 403 Forbidden
end

== Get Token Info ==

Admin -> App: View token info
App -> API: GET /api/v1/integrations/shopify/token\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware + RoleMiddleware
API -> DB: SELECT FROM partner_accounts
DB --> API: Account record
API -> API: Decrypt & mask token
API --> App: 200 OK\n{ "masked_token": "***...xxxx",\n"partner_id": "12345",\n"integration_type": "MANUAL" }

== Revoke Token ==

Admin -> App: Click "Revoke Token"
App -> API: DELETE /api/v1/integrations/shopify/token\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware + RoleMiddleware
API -> DB: DELETE FROM partner_accounts\nWHERE user_id = ?
DB --> API: Success
API --> App: 200 OK\n{ "message": "Token revoked successfully" }

' ==========================================
' 5. App Selection Flow
' ==========================================
newpage App Selection Flow

actor User
participant "Client App" as App
participant "API Server" as API
participant "Shopify Partner API" as Shopify
database "PostgreSQL" as DB

== Fetch Available Apps ==

User -> App: View available apps
App -> API: GET /api/v1/apps/available\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account with encrypted_token

API -> API: Decrypt access token (AES-256-GCM)

API -> Shopify: POST GraphQL\n{ query: "apps { edges { node { id name } } }" }
Shopify --> API: List of apps

API --> App: 200 OK\n{ "apps": [{"id": "gid://...", "name": "App One"}, ...] }

== Select App ==

User -> App: Click "Track this app"
App -> API: POST /api/v1/apps/select\n{ "partner_app_id": "gid://...", "name": "App One" }

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account

API -> DB: SELECT FROM apps\nWHERE partner_app_id = ?
alt App already tracked
    DB --> API: Existing app
    API --> App: 409 Conflict\n{ "error": "app already tracked" }
else App not tracked
    DB --> API: Not found
    API -> DB: INSERT INTO apps\n(partner_account_id, partner_app_id, name)
    DB --> API: Success
    API --> App: 201 Created\n{ "id": "uuid", "name": "App One" }
end

== List Tracked Apps ==

User -> App: View my apps
App -> API: GET /api/v1/apps\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account

API -> DB: SELECT FROM apps\nWHERE partner_account_id = ?
DB --> API: List of tracked apps

API --> App: 200 OK\n{ "apps": [{"id": "uuid", "name": "App One", "tracking_enabled": true}] }

' ==========================================
' 6. Transaction Sync Flow
' ==========================================
newpage Transaction Sync Flow

actor User
participant "Client App" as App
participant "API Server" as API
participant "SyncService" as Sync
participant "Shopify Partner API" as Shopify
database "PostgreSQL" as DB

== On-Demand Sync (All Apps) ==

User -> App: Click "Sync Now"
App -> API: POST /api/v1/sync\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account

API -> Sync: SyncAllApps(partnerAccountID)

Sync -> DB: SELECT FROM apps\nWHERE partner_account_id = ?
DB --> Sync: List of tracked apps

loop For each app with tracking_enabled = true
    Sync -> DB: SELECT FROM partner_accounts\nWHERE id = ?
    DB --> Sync: Partner account with encrypted_token

    Sync -> Sync: Decrypt access token (AES-256-GCM)

    Sync -> Shopify: POST GraphQL\nFetch transactions (12-month window)
    Shopify --> Sync: List of transactions

    Sync -> DB: UPSERT transactions\n(ON CONFLICT shopify_gid DO UPDATE)
    DB --> Sync: Success
end

Sync --> API: SyncResults[]

API --> App: 200 OK\n{ "results": [{"app_name": "App", "transaction_count": 50}] }

== On-Demand Sync (Single App) ==

User -> App: Click "Sync App"
App -> API: POST /api/v1/sync/{appID}\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> Sync: SyncApp(appID)

Sync -> DB: SELECT FROM apps WHERE id = ?
DB --> Sync: App record

Sync -> DB: SELECT FROM partner_accounts\nWHERE id = app.partner_account_id
DB --> Sync: Partner account with encrypted_token

Sync -> Sync: Decrypt access token

Sync -> Shopify: POST GraphQL\nFetch transactions (12-month window)
Shopify --> Sync: List of transactions

Sync -> DB: UPSERT batch transactions
DB --> Sync: Success

Sync --> API: SyncResult

API --> App: 200 OK\n{ "app_name": "App", "transaction_count": 50 }

== Scheduled Sync (12-hour interval) ==

note over Sync: SyncScheduler runs at 00:00 and 12:00 UTC

Sync -> Sync: Timer fires

loop For each partner account
    Sync -> Sync: SyncAllApps(partnerAccountID)
end

Sync -> Sync: Log results

' ==========================================
' 7. Ledger Rebuild Flow
' ==========================================
newpage Ledger Rebuild Flow

participant "LedgerService" as Ledger
database "PostgreSQL" as DB

note over Ledger
  Deterministic rebuild:
  Same transactions â†’ Same subscriptions
end note

== Rebuild From Transactions ==

Ledger -> DB: SELECT transactions\nWHERE app_id = ? AND date >= 12_months_ago
DB --> Ledger: All transactions

Ledger -> Ledger: Group by myshopify_domain

loop For each store domain
    Ledger -> Ledger: Filter RECURRING transactions
    Ledger -> Ledger: Sort by transaction_date
    Ledger -> Ledger: Get most recent charge
    Ledger -> Ledger: Detect billing interval\n(MONTHLY vs ANNUAL)
    Ledger -> Ledger: Calculate expected_next_charge_date\n(last_charge + interval)
    Ledger -> Ledger: Classify risk state
end

Ledger -> DB: DELETE subscriptions\nWHERE app_id = ?
DB --> Ledger: Cleared

loop For each subscription
    Ledger -> DB: INSERT subscription\n(ON CONFLICT DO UPDATE)
    DB --> Ledger: Saved
end

Ledger -> Ledger: Calculate totals:\n- MRR (RECURRING only)\n- Usage Revenue (USAGE only)\n- Risk summary counts

Ledger --> Ledger: LedgerRebuildResult

note over Ledger
  Risk Classification:
  - 0-30 days past due: SAFE
  - 31-60 days past due: ONE_CYCLE_MISSED
  - 61-90 days past due: TWO_CYCLES_MISSED
  - >90 days past due: CHURNED
end note

@enduml
