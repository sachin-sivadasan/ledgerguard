@startuml SEQUENCE_LedgerGuard_Current
!theme plain

title LedgerGuard - Sequence Diagrams (Current Implementation)

' ==========================================
' 1. Authentication Flow
' ==========================================
newpage Authentication Flow

actor User
participant "Client App" as App
participant "Firebase Auth" as Firebase
participant "API Server" as API
database "PostgreSQL" as DB

User -> App: Login with Google
App -> Firebase: signInWithGoogle()
Firebase --> App: Firebase ID Token

App -> API: Request with\nAuthorization: Bearer <token>
API -> API: AuthMiddleware intercepts

API -> Firebase: verifyIdToken(token)
Firebase --> API: { uid, email }

API -> DB: SELECT * FROM users\nWHERE firebase_uid = ?

alt User exists
    DB --> API: User record
else New user (first login)
    API -> DB: INSERT INTO users\n(firebase_uid, email, role='OWNER')
    DB --> API: New user record
end

API -> API: Set user in request context
API -> API: Continue to handler
API --> App: Response with user context

' ==========================================
' 2. Role-Based Access Control
' ==========================================
newpage Role-Based Access Control

actor User
participant "Client App" as App
participant "API Server" as API

App -> API: Request to protected endpoint\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware\n(verify token, load user)

API -> API: RoleMiddleware\n(check RequireRoles)

alt User has required role
    note right of API: OWNER has access to all routes\nADMIN only to ADMIN routes
    API -> API: Continue to handler
    API --> App: 200 OK + Response
else Insufficient permissions
    API --> App: 403 Forbidden\n{"error": "insufficient permissions"}
end

' ==========================================
' 3. Shopify Partner OAuth Flow
' ==========================================
newpage Shopify Partner OAuth Flow

actor User
participant "Client App" as App
participant "API Server" as API
participant "Shopify Partners" as Shopify
database "PostgreSQL" as DB

User -> App: Click "Connect Shopify"

App -> API: GET /api/v1/integrations/shopify/oauth\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> API: Generate OAuth state token
API -> API: Build Shopify OAuth URL\n(client_id, redirect_uri, scopes, state)

API --> App: 302 Redirect to Shopify

App -> Shopify: GET /oauth/authorize?...
Shopify --> User: "Authorize LedgerGuard?"

User -> Shopify: Click "Approve"

Shopify --> App: 302 Redirect to callback\n?code=xxx&state=yyy

App -> API: GET /api/v1/integrations/shopify/callback\n?code=xxx&state=yyy

API -> API: Validate state token
API -> API: Get user from context

API -> Shopify: POST /oauth/access_token\n{ code, client_id, client_secret }
Shopify --> API: { access_token, organization_id }

API -> API: Encrypt token\n(AES-256-GCM)

API -> DB: INSERT INTO partner_accounts\n(user_id, partner_id, integration_type='OAUTH',\nencrypted_access_token)

DB --> API: Success

API --> App: 200 OK\n{"success": true, "partner_id": "..."}

App --> User: "Connected successfully!"

' ==========================================
' 4. Manual Token Flow (ADMIN only)
' ==========================================
newpage Manual Token Flow (ADMIN only)

actor Admin
participant "Client App" as App
participant "API Server" as API
database "PostgreSQL" as DB

== Add Manual Token ==

Admin -> App: Enter partner token & ID
App -> API: POST /api/v1/integrations/shopify/token\n[Authorization: Bearer <token>]\n{ "token": "shppa_xxx", "partner_id": "12345" }

API -> API: AuthMiddleware (verify user)
API -> API: RoleMiddleware (require ADMIN)

alt User is ADMIN or OWNER
    API -> API: Encrypt token (AES-256-GCM)
    API -> DB: INSERT/UPDATE partner_accounts
    DB --> API: Success
    API --> App: 201 Created\n{ "masked_token": "***...xxxx" }
else Not ADMIN
    API --> App: 403 Forbidden
end

== Get Token Info ==

Admin -> App: View token info
App -> API: GET /api/v1/integrations/shopify/token\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware + RoleMiddleware
API -> DB: SELECT FROM partner_accounts
DB --> API: Account record
API -> API: Decrypt & mask token
API --> App: 200 OK\n{ "masked_token": "***...xxxx",\n"partner_id": "12345",\n"integration_type": "MANUAL" }

== Revoke Token ==

Admin -> App: Click "Revoke Token"
App -> API: DELETE /api/v1/integrations/shopify/token\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware + RoleMiddleware
API -> DB: DELETE FROM partner_accounts\nWHERE user_id = ?
DB --> API: Success
API --> App: 200 OK\n{ "message": "Token revoked successfully" }

' ==========================================
' 5. App Selection Flow
' ==========================================
newpage App Selection Flow

actor User
participant "Client App" as App
participant "API Server" as API
participant "Shopify Partner API" as Shopify
database "PostgreSQL" as DB

== Fetch Available Apps ==

User -> App: View available apps
App -> API: GET /api/v1/apps/available\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account with encrypted_token

API -> API: Decrypt access token (AES-256-GCM)

API -> Shopify: POST GraphQL\n{ query: "apps { edges { node { id name } } }" }
Shopify --> API: List of apps

API --> App: 200 OK\n{ "apps": [{"id": "gid://...", "name": "App One"}, ...] }

== Select App ==

User -> App: Click "Track this app"
App -> API: POST /api/v1/apps/select\n{ "partner_app_id": "gid://...", "name": "App One" }

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account

API -> DB: SELECT FROM apps\nWHERE partner_app_id = ?
alt App already tracked
    DB --> API: Existing app
    API --> App: 409 Conflict\n{ "error": "app already tracked" }
else App not tracked
    DB --> API: Not found
    API -> DB: INSERT INTO apps\n(partner_account_id, partner_app_id, name)
    DB --> API: Success
    API --> App: 201 Created\n{ "id": "uuid", "name": "App One" }
end

== List Tracked Apps ==

User -> App: View my apps
App -> API: GET /api/v1/apps\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account

API -> DB: SELECT FROM apps\nWHERE partner_account_id = ?
DB --> API: List of tracked apps

API --> App: 200 OK\n{ "apps": [{"id": "uuid", "name": "App One", "tracking_enabled": true}] }

' ==========================================
' 6. Transaction Sync Flow
' ==========================================
newpage Transaction Sync Flow

actor User
participant "Client App" as App
participant "API Server" as API
participant "SyncService" as Sync
participant "Shopify Partner API" as Shopify
database "PostgreSQL" as DB

== On-Demand Sync (All Apps) ==

User -> App: Click "Sync Now"
App -> API: POST /api/v1/sync\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> DB: SELECT FROM partner_accounts\nWHERE user_id = ?
DB --> API: Partner account

API -> Sync: SyncAllApps(partnerAccountID)

Sync -> DB: SELECT FROM apps\nWHERE partner_account_id = ?
DB --> Sync: List of tracked apps

loop For each app with tracking_enabled = true
    Sync -> DB: SELECT FROM partner_accounts\nWHERE id = ?
    DB --> Sync: Partner account with encrypted_token

    Sync -> Sync: Decrypt access token (AES-256-GCM)

    Sync -> Shopify: POST GraphQL\nFetch transactions (12-month window)
    Shopify --> Sync: List of transactions

    Sync -> DB: UPSERT transactions\n(ON CONFLICT shopify_gid DO UPDATE)
    DB --> Sync: Success
end

Sync --> API: SyncResults[]

API --> App: 200 OK\n{ "results": [{"app_name": "App", "transaction_count": 50}] }

== On-Demand Sync (Single App) ==

User -> App: Click "Sync App"
App -> API: POST /api/v1/sync/{appID}\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> Sync: SyncApp(appID)

Sync -> DB: SELECT FROM apps WHERE id = ?
DB --> Sync: App record

Sync -> DB: SELECT FROM partner_accounts\nWHERE id = app.partner_account_id
DB --> Sync: Partner account with encrypted_token

Sync -> Sync: Decrypt access token

Sync -> Shopify: POST GraphQL\nFetch transactions (12-month window)
Shopify --> Sync: List of transactions

Sync -> DB: UPSERT batch transactions
DB --> Sync: Success

Sync --> API: SyncResult

API --> App: 200 OK\n{ "app_name": "App", "transaction_count": 50 }

== Scheduled Sync (12-hour interval) ==

note over Sync: SyncScheduler runs at 00:00 and 12:00 UTC

Sync -> Sync: Timer fires

loop For each partner account
    Sync -> Sync: SyncAllApps(partnerAccountID)
end

Sync -> Sync: Log results

' ==========================================
' 7. Ledger Rebuild Flow
' ==========================================
newpage Ledger Rebuild Flow

participant "LedgerService" as Ledger
database "PostgreSQL" as DB

note over Ledger
  Deterministic rebuild:
  Same transactions → Same subscriptions
end note

== Rebuild From Transactions ==

Ledger -> DB: SELECT transactions\nWHERE app_id = ? AND date >= 12_months_ago
DB --> Ledger: All transactions

Ledger -> Ledger: Group by myshopify_domain

loop For each store domain
    Ledger -> Ledger: Filter RECURRING transactions
    Ledger -> Ledger: Sort by transaction_date
    Ledger -> Ledger: Get most recent charge
    Ledger -> Ledger: Detect billing interval\n(MONTHLY vs ANNUAL)
    Ledger -> Ledger: Calculate expected_next_charge_date\n(last_charge + interval)
    Ledger -> Ledger: Classify risk state
end

Ledger -> DB: DELETE subscriptions\nWHERE app_id = ?
DB --> Ledger: Cleared

loop For each subscription
    Ledger -> DB: INSERT subscription\n(ON CONFLICT DO UPDATE)
    DB --> Ledger: Saved
end

Ledger -> Ledger: Calculate totals:\n- MRR (RECURRING only)\n- Usage Revenue (USAGE only)\n- Risk summary counts

Ledger --> Ledger: LedgerRebuildResult

note over Ledger
  Risk Classification:
  - 0-30 days past due: SAFE
  - 31-60 days past due: ONE_CYCLE_MISSED
  - 61-90 days past due: TWO_CYCLES_MISSED
  - >90 days past due: CHURNED
end note

' ==========================================
' 8. Metrics Retrieval with Time Filtering
' ==========================================
newpage Metrics Retrieval with Time Filtering

actor User
participant "Client App" as App
participant "API Server" as API
participant "MetricsAggregationService" as MetricsAgg
participant "MetricsEngine" as Engine
database "PostgreSQL" as DB

User -> App: Select time range\n(This Month, Last 30 Days, etc.)
App -> API: GET /api/v1/apps/{appID}/metrics\n?start=2024-02-01&end=2024-02-15\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> API: Validate app ownership

API -> MetricsAgg: GetPeriodMetrics(appID, dateRange)

MetricsAgg -> MetricsAgg: Calculate previous period\n(same duration, immediately before)

par Fetch data in parallel
    MetricsAgg -> DB: SELECT daily_metrics_snapshot\nWHERE app_id = ? AND date BETWEEN current_start AND current_end
    DB --> MetricsAgg: Current period snapshots

    MetricsAgg -> DB: SELECT daily_metrics_snapshot\nWHERE app_id = ? AND date BETWEEN prev_start AND prev_end
    DB --> MetricsAgg: Previous period snapshots

    MetricsAgg -> DB: SELECT transactions\nWHERE app_id = ? AND date BETWEEN current_start AND current_end
    DB --> MetricsAgg: Current period transactions

    MetricsAgg -> DB: SELECT transactions\nWHERE app_id = ? AND date BETWEEN prev_start AND prev_end
    DB --> MetricsAgg: Previous period transactions
end

MetricsAgg -> MetricsAgg: Get latest snapshot for point-in-time metrics\n(MRR, risk counts, renewal rate)

MetricsAgg -> Engine: CalculateUsageRevenue(currentTxs)
Engine --> MetricsAgg: Usage revenue for period

MetricsAgg -> Engine: CalculateTotalRevenue(currentTxs)
Engine --> MetricsAgg: Total revenue for period

MetricsAgg -> MetricsAgg: Repeat for previous period

MetricsAgg -> MetricsAgg: Calculate deltas:\n- (current - previous) / previous * 100

MetricsAgg --> API: PeriodMetrics {\n  current: MetricsSummary,\n  previous: MetricsSummary,\n  delta: MetricsDelta\n}

API --> App: 200 OK\n{ current: {...}, previous: {...}, delta: {...} }

App --> User: Display KPIs with\ndelta badges (green/red)

note over MetricsAgg
  Point-in-time metrics from snapshots:
  - Active MRR
  - Revenue at Risk
  - Renewal Success Rate
  - Risk state counts

  Period revenue from transactions:
  - Usage Revenue (sum of USAGE charges)
  - Total Revenue (sum of all charges)
end note

' ==========================================
' 9. Subscription List with Filtering
' ==========================================
newpage Subscription List with Filtering

actor User
participant "Client App" as App
participant "API Server" as API
database "PostgreSQL" as DB

User -> App: View subscriptions\n(filter by risk state)
App -> API: GET /api/v1/apps/{appID}/subscriptions\n?risk_state=ONE_CYCLE_MISSED&limit=50&offset=0\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> API: Validate app ownership

alt Filter by risk_state
    API -> DB: SELECT * FROM subscriptions\nWHERE app_id = ? AND risk_state = ?\nORDER BY base_price_cents DESC\nLIMIT ? OFFSET ?
else No filter
    API -> DB: SELECT * FROM subscriptions\nWHERE app_id = ?\nORDER BY base_price_cents DESC\nLIMIT ? OFFSET ?
end

DB --> API: Subscriptions with shop_name

API -> DB: SELECT COUNT(*) FROM subscriptions\nWHERE app_id = ? [AND risk_state = ?]
DB --> API: Total count

API --> App: 200 OK\n{\n  subscriptions: [{id, shop_name, plan_name, risk_state, ...}],\n  total: 150,\n  limit: 50,\n  offset: 0\n}

App --> User: Display subscription list\nwith risk badges (SAFE=green,\nONE_CYCLE=yellow, TWO_CYCLES=orange,\nCHURNED=red)

' ==========================================
' 10. Webhook Processing Flow
' ==========================================
newpage Webhook Processing Flow

participant "Shopify" as Shopify
participant "API Server" as API
participant "WebhookService" as Webhook
database "PostgreSQL" as DB

note over Shopify, DB
  Real-time subscription updates via Shopify webhooks.
  Endpoints: /webhooks/shopify/*
  No auth (validated via HMAC signature)
end note

== Subscription Update Webhook ==

Shopify -> API: POST /webhooks/shopify/subscriptions\n[X-Shopify-Topic: app_subscriptions/update]\n[X-Shopify-Hmac-Sha256: <signature>]\n{ status: "CANCELLED", ... }

API -> API: Read request body
API -> Webhook: ValidateHMAC(appID, body, signature)

alt HMAC Valid
    Webhook --> API: true
else HMAC Invalid
    Webhook --> API: false
    API --> Shopify: 401 Unauthorized
end

API -> Webhook: ProcessSubscriptionUpdate(event)

Webhook -> DB: SELECT * FROM subscriptions\nWHERE shopify_gid = ?
DB --> Webhook: Subscription record

Webhook -> Webhook: Store old status/risk_state

Webhook -> Webhook: Update status from payload\n(ACTIVE → CANCELLED)

Webhook -> Webhook: Update risk_state based on status\n(CANCELLED → CHURNED)

Webhook -> DB: UPDATE subscriptions\nSET status = ?, risk_state = ?, updated_at = NOW()
DB --> Webhook: Success

Webhook -> DB: INSERT INTO subscription_events\n(subscription_id, from_status, to_status,\nfrom_risk_state, to_risk_state, event_type='webhook')
DB --> Webhook: Event recorded

Webhook --> API: nil (success)
API --> Shopify: 200 OK

note over Webhook
  Always return 200 OK to prevent
  Shopify from retrying.
  Errors are logged internally.
end note

== App Uninstalled Webhook ==

Shopify -> API: POST /webhooks/shopify/uninstalled\n[X-Shopify-Topic: app/uninstalled]\n{ myshopify_domain: "store.myshopify.com" }

API -> Webhook: ProcessAppUninstalled(event)

Webhook -> DB: SELECT * FROM apps\nWHERE partner_app_id = ?
DB --> Webhook: App records

loop For each matching app
    Webhook -> DB: SELECT * FROM subscriptions\nWHERE app_id = ? AND myshopify_domain = ?
    DB --> Webhook: Subscription

    Webhook -> Webhook: Mark as UNINSTALLED + CHURNED
    Webhook -> Webhook: Soft delete (set deleted_at)

    Webhook -> DB: UPDATE subscriptions\nSET status='UNINSTALLED', risk_state='CHURNED',\ndeleted_at=NOW()
    DB --> Webhook: Success

    Webhook -> DB: INSERT INTO subscription_events\n(event_type='app_uninstalled', reason='Shop uninstalled the app')
    DB --> Webhook: Event recorded
end

Webhook --> API: nil
API --> Shopify: 200 OK

== Billing Failure Webhook ==

Shopify -> API: POST /webhooks/shopify/billing-failure\n[X-Shopify-Topic: subscription_billing_attempts/failure]\n{ error_code: "card_declined", ... }

API -> Webhook: ProcessBillingFailure(event)

Webhook -> DB: SELECT * FROM subscriptions\nWHERE shopify_gid = ?
DB --> Webhook: Subscription

Webhook -> Webhook: Escalate risk state:\nSAFE → ONE_CYCLE_MISSED\nONE_CYCLE_MISSED → TWO_CYCLES_MISSED\nTWO_CYCLES_MISSED → CHURNED

Webhook -> DB: UPDATE subscriptions\nSET risk_state = ?, updated_at = NOW()
DB --> Webhook: Success

Webhook -> DB: INSERT INTO subscription_events\n(event_type='billing_failure',\nreason='Billing failure: card_declined')
DB --> Webhook: Event recorded

Webhook --> API: nil
API --> Shopify: 200 OK

note over Webhook
  Risk State Escalation on Billing Failure:
  - SAFE → ONE_CYCLE_MISSED (first failure)
  - ONE_CYCLE_MISSED → TWO_CYCLES_MISSED
  - TWO_CYCLES_MISSED → CHURNED

  This is "involuntary churn" - distinguished
  from voluntary churn (user cancellation).
end note

' ==========================================
' 11. AI Daily Brief Generation Flow
' ==========================================
newpage AI Daily Brief Generation Flow

participant "Scheduler" as Scheduler
participant "InsightService" as Insight
participant "AI Provider" as AI
database "PostgreSQL" as DB

note over Scheduler, DB
  Generates 80-120 word executive summaries
  from daily metrics snapshots.
  Pro tier only.
end note

== Daily Brief Generation (Scheduled) ==

Scheduler -> Scheduler: Cron job fires (e.g., 07:00 UTC)

Scheduler -> DB: SELECT u.*, pa.id as partner_account_id\nFROM users u\nJOIN partner_accounts pa ON u.id = pa.user_id\nWHERE u.plan_tier = 'PRO'
DB --> Scheduler: Pro users with partner accounts

loop For each Pro user
    Scheduler -> DB: SELECT a.id FROM apps a\nWHERE a.partner_account_id = ?
    DB --> Scheduler: User's apps

    loop For each app
        Scheduler -> Insight: GenerateDailyBrief(appID, date)

        Insight -> DB: SELECT * FROM daily_metrics_snapshot\nWHERE app_id = ? AND date = ?\nORDER BY date DESC LIMIT 1
        DB --> Insight: Latest snapshot

        Insight -> DB: SELECT * FROM daily_metrics_snapshot\nWHERE app_id = ? AND date < ?\nORDER BY date DESC LIMIT 1
        DB --> Insight: Previous snapshot (for comparison)

        alt Snapshots exist
            Insight -> Insight: Build context:\n- MRR change\n- Risk distribution\n- Churn events\n- Notable changes

            Insight -> AI: Generate insight\n(prompt + metrics context)
            AI --> Insight: "Your MRR grew 5% this week...\n(80-120 words)"

            Insight -> DB: INSERT INTO daily_insight\n(app_id, date, insight_text)\nON CONFLICT (app_id, date) DO UPDATE
            DB --> Insight: Success

            Insight --> Scheduler: Brief generated
        else No data
            Insight --> Scheduler: Skipped (no metrics)
        end
    end
end

Scheduler -> Scheduler: Log completion

== Retrieve Daily Brief (On-Demand) ==

actor User
participant "Client App" as App
participant "API Server" as API

User -> App: View today's insight
App -> API: GET /api/v1/apps/{appID}/insights/today\n[Authorization: Bearer <token>]

API -> API: AuthMiddleware (verify user)
API -> API: Check plan_tier = 'PRO'

alt Pro tier
    API -> DB: SELECT * FROM daily_insight\nWHERE app_id = ? AND date = CURRENT_DATE
    DB --> API: Insight or null

    alt Insight exists
        API --> App: 200 OK\n{ "insight": "Your MRR grew 5%...", "date": "2024-02-01" }
    else No insight yet
        API --> App: 200 OK\n{ "insight": null, "message": "Insight not yet generated" }
    end
else Free tier
    API --> App: 403 Forbidden\n{ "error": "Pro tier required for AI insights" }
end

App --> User: Display AI insight card\n(or upgrade prompt)

' ==========================================
' 12. Revenue API Flow (External Access)
' ==========================================
newpage Revenue API Flow (External Access)

participant "External System" as External
participant "API Server" as API
participant "RateLimiter" as RateLimit
database "PostgreSQL" as DB

note over External, DB
  External access to subscription status
  and usage data via API keys.
  Rate-limited per key.
end note

== API Key Authentication ==

External -> API: GET /revenue-api/v1/subscriptions/{gid}\n[X-Api-Key: lg_xxx...]

API -> API: Extract API key from header
API -> API: Hash key with SHA-256

API -> DB: SELECT * FROM api_keys\nWHERE key_hash = ? AND revoked_at IS NULL
DB --> API: API key record (or null)

alt Key valid
    API -> API: Load associated user
    API -> RateLimit: Check rate limit\n(key_id, limit=60/min)

    alt Under rate limit
        RateLimit --> API: Allowed

        API -> DB: SELECT * FROM api_subscription_status\nWHERE shopify_gid = ?
        DB --> API: Subscription status

        API -> DB: INSERT INTO api_audit_log\n(api_key_id, endpoint, method, response_status)
        DB --> API: Audit logged

        API --> External: 200 OK\n{ subscription: { risk_state, is_paid, ... } }
    else Rate exceeded
        RateLimit --> API: Denied
        API --> External: 429 Too Many Requests\n{ "error": "rate_limit_exceeded" }
    end
else Key invalid or revoked
    API --> External: 401 Unauthorized\n{ "error": "invalid_api_key" }
end

== Batch Query (Multiple Subscriptions) ==

External -> API: POST /revenue-api/v1/subscriptions/batch\n[X-Api-Key: lg_xxx...]\n{ "shopify_gids": ["gid://...", "gid://..."] }

API -> API: Validate API key
API -> RateLimit: Check rate limit

API -> DB: SELECT * FROM api_subscription_status\nWHERE shopify_gid = ANY($1)
DB --> API: Multiple subscription statuses

API -> DB: Log audit entry

API --> External: 200 OK\n{ "subscriptions": [{ ... }, { ... }] }

@enduml
